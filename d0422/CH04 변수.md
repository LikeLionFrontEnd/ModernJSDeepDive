# 04. 변수

# 변수란 무엇인가?

```jsx
10+20
```

해당 식을 계산하기 위해서는 10, 20, + 기호의 의미를 이해하고, 10+20이라는 식의 의미도 파악할 수 있어야 한다.

숫자 10과 20은 메모리 어딘가에 기억되고, CPU는 이 값을 읽어 연산을 수행한다.

결과로 생성된 숫자 30도 메모리상의 임의 위치에 저장된다.

이 10과 20, 30은 절대 다시 접근하여 사용할 수 없다.

메모리에 접근할 수도 있지만, 매우 치명적인 오류를 초래할 수도 있기에 자바스크립트는 직접적인 메모리 제어를 제공하지 않는다. 또한, 메모리 주소를 알 수 있는 방법도 없으므로, 사용이 불가능하다 할 수 있다.

이를 해결하기위해 제공되는 것이 **변수**이다.

## 변수

하나의 값을 저장하기 위해 확보한 메모리 공간, 메모리 공간을 식별하기 위해 붙인 이름

즉, **값의 위치를 가리키는 상징적인 이름**

인터프리터에 의해 값이 메모리 공간의 주소로 치환되어 실행되어 안전하게 사용이 가능해짐!

```jsx
var a=1
```

a를 변수이름, 1을 변수 값, 이렇게 쓴 식을 할당이라 한다. 

이렇게 만든 변수를 사용하는 것을 **참조**라고 한다.

## 식별자

식별자는 어떤 값을 구별해서 식별할 수 있는고유한 이름

식별자는 값이 아니라 메모리 주소를 기억하고 있음

변수, 함수, 클래스 등의 이름은 모두 식별자

**선언**을 통해 자바스크립트엔진에 식별자의 존재를 알림

## 변수 선언

변수 사용시 선언 키워드는 var, let, const이다.

### var의 단점

블록레벨 스코프를 지원하지 않고, 함수레벨 스코프를 지원한다는 것

블록레벨과 함수레벨의 차이

```jsx
//scope
{
  var a = 1;
  let b = 1;
  const c = 1;
}
try {
  console.log(a);
  console.log(b); //Error
} catch (err) {
  console.log(err);
  try {
    console.log(c); //Error
  } catch (err) {
    console.log(err);
  }
}
```

## 선언

var 키워드를 사용해서 변수를 선언한다.

```jsx
var score
```

이러면 메모리 공간이 확보되고, score라는 식별자를 통해 값을 참조할 수 있게 된다.

하지만, 아직 값을 할당하지는 않았다.

그러나 **자바스크립트 엔진은 할당되지 않은 변수에 undefined를 암묵적으로 할당하여 초기화 한다.**

### 변수 선언의 단계

1. 선언단계 : 변수이름을 등록해서 자바스크립트 엔진에 변수의 존재를 알린다.
2. 초기화단계 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 undefined를 할당해 초기화한다.

### 변수는 어디에 등록되는가?

이름을 비롯한 모든 식별자는 실행컨텍스트에 등록된다.

자바스크립트 엔진은 실행컨텍스트를 통해 식별자와 스코프를 관리한다.

변수 이름과 변수 값은 실행 컨텍스트 내의 키/값 형태의 객체로 등록되어 관리된다.

## 변수 호이스팅

```jsx
console.log(score);
var score;
```

놀랍게도 오류가 발생하지 않는다. 

변수 선언은 런타임이 아니라 그 이전 단계에서 먼저 실행되기 때문이다.

자바스크립트는 한줄씩 실행하기에 앞서 먼저 소스코드의 평가 과정을 거치면서 소스코드를 실행하기 위한 준비를 한다.

이때 변수선언, 함수선언 등 모든 선언문을 소스코드 에서 찾아서 먼저 실행한다.

이것을 **변수 호이스팅**이라 한다.

var, let, const, function, function*, class도 모두 호이스팅 된다.

## 값의 할당

변수에 값을 할당할때는 할당 연산자를 사용한다. 

할당 연산자는 =를 사용한다.

변수의 선언과 값의 할당을 하나의 문으로 단축 표현할 수도 있다.

```jsx
var score=80;
```

그러나, var score와 score=80은 다른 시점이 실행된다.

그래서 이런 결과가 나오는 것이다.

```jsx
console.log(score);// undefined
var score=80;
console.log(score); //80

```

이런 것도 가능하다.

```jsx
console.log(score); // undefined
score=80;
var score;
console.log(score); // 80
```

## 값의 재할당

이미 값이 할당 된 변수에 새로운 값을 또다시 할당하는 것

엄밀히 말하면 var로 선언된 변수에 할당하는 것도 재할당임

상수는 재할당 할 수 없다.(const)

```jsx
var score=80;
score=90;
```

이런 식으로 코드를 작성하면 이후 80은 score와 연결이 끊겨 다시는 재사용할 수 없게 된다.

기존 메모리 공간은 지워지고, 새롭게 메모리공간을 확보해 90을 저장한다.

80처럼, 식별자와 연결이 끊긴 값들은 가비지 콜랙터에 의해 메모리에서 자동 해제된다.

단, 언제 해제될 지는 예측할 수 없다.

## 식별자 네이밍 규칙

1. 식별자는 특수문자를 제외한 문자, 숫자, 언더스코어(_),  $를 포함할 수 있다.
2. 단 식별자는 특수문자를 제외한 문자, _,$로 시작해야한다. 숫자로 시작하는 것은 허용하지 않는다.
3. 예약어는 식별자로 사용할 수 없다.