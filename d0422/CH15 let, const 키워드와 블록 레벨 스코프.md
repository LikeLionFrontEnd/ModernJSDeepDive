# 15 let const 키워드와 블록 레벨 스코프

# var 키워드로 선언한 변수의 문제점

### 변수 중복 선언 허용

```jsx
var x=1;
var y =1;
var x=100;
var y;
console.log(x); //100
console.log(y); //1
```

### 함수 레벨 스코프

var 키워드로 선언한 변수는 오로지 함수의 코드블록만을 지역스코프로 인정한다.

함수 외부에서 var 키워드를 선언하면 코드 블록 내에서 선언해도 모두 전역 변수가 된다.

```jsx
var x=1;
if(true){
	var x=10;
}
console.log(x); //10
```

### 변수 호이스팅

var 키워드로 변수를 선언하면 변수 호이스팅에 의해 변수 선언문이 스코프의 선두로 끌어올려져서 동작한다.

따라서 할당문 이전에 참조가 가능하며, undefined를 반환한다.

이런 코드가 문제 없이 작동하게 된다.

```jsx
console.log(foo); //undefined
foo = 123;
console.log(foo); //123
var foo;
```

# let 키워드

### 변수 중복 선언금지

let 키워드로 변수를 중복선언하면 문법 에러가 발생한다.

### 블록레벨 스코프

var로 선언한 변수는 오로지 함수 코드블록만을 지역스코프로 인정한다. 하지만, let은 모든 코드블록을 지역스코프로 인정한다.

```jsx
let foo=1;
{
		let foo=2;
		let bar=1;
}
console.log(foo); //1
console.log(bar); //Error
```

두가지 foo는 다른 스코프를 갖는 변수이다.

### 변수호이스팅

var 키워드와 달리 변수 호이스팅이 발생하지 않는 것처럼 동작한다.

```jsx
console.log(foo); //Error
let foo;
```

var키워드는 선언과 초기화가 동시에 일어나고, 할당은 나중에 해도 된다.

let 키워드는 이와달리 선언단계와 초기화 단계가 분리되어 진행된다.

선언단계는 js 엔진에 의해 암묵적으로 이뤄지지만, 초기화 단계는 변수 선언문에 도달했을때 이뤄진다.

만약 초기화 단계가 이뤄지기 전에 변수에 접근하면 참조 에러가 발생한다.

스코프 시작지점부터 초기화 시작지점까지 변수를 참조할 수 없는 구간을 **일시적 사각지대(TDZ)**라고 부른다.

**하지만 호이스팅은 일어난다.**

```jsx
let foo=1;
{
	console.log(foo); //ReferenceError
	let foo=2;
}
```

블록 스코프에서 호이스팅이 일어났기때문에 참조오류가 발생하게 된다.

즉, 호이스팅이 발생하지 않는 것처럼 보이지만, 호이스팅 자체는 일어난다는 것

### 전역객체와 let

var 키워드로 브라우저에서 전역변수를 선언하면 자동적으로 window객체에 프로퍼티로 추가된다.

```jsx
var x=1;
console.log(window.x); //1
```

let은 전역객체에 추가되지 않는다.

```jsx
let x=1;
console.log(window.x); //undefined
console.log(x); // 1
```

# const 키워드

const 키워드는 상수를 선언하기 위해 사용한다.

let과 비슷하게 작동한다.

### 선언과 초기화

const 키워드는 반드시 선언과 동시에 초기화한다.

```jsx
const foo=1;
```

그렇지 않으면 문법에러가 발생한다.

### 스코프

블록레벨 스코프이며, 호이스팅이 발생하지 않는 것처럼 동작한다.

### 재할당 금지

const 키워드로 선언된 변수는 재할당이 금지된다.

⇒ const 키워드에 원시값을 할당하여 상수로 사용한다. 

### const와 객체

객체는 그 자체 값이 변할 수 있으므로 const로 선언해도 프로퍼티 등 내부 값이 변할 수 있다.

# var, let, const

변수 선언에는 기본적으로 const를 사용하고 재할당이 필요한 경우에만 let을 사용하자.

ES6를 사용한다면 var를 사용하지 않는다.