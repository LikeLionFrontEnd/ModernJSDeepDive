# 11 원시 값과 객체의 비교

# 원시값

### 변경 불가능한 값

원시타입의 값은 변경 불가능한 값이다.

한번 생성된 원시값은 읽기전용이라 변경이 불가능하다.

### 값과 변수

변수는 변할 수 있지만, 값은 그렇지 않을 수 있다.

변수가 가르키는 원시값의 주소가 바뀌는 것이다.

```jsx
var p;
```

![Untitled](11%20%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%89%E1%85%B5%20%E1%84%80%E1%85%A1%E1%86%B9%E1%84%80%E1%85%AA%20%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%E1%84%8B%E1%85%B4%20%E1%84%87%E1%85%B5%E1%84%80%E1%85%AD%206ecfc068280d4667846e774f3f1bc448/Untitled.png)

```jsx
var p;
p=10;
```

![Untitled](11%20%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%89%E1%85%B5%20%E1%84%80%E1%85%A1%E1%86%B9%E1%84%80%E1%85%AA%20%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%E1%84%8B%E1%85%B4%20%E1%84%87%E1%85%B5%E1%84%80%E1%85%AD%206ecfc068280d4667846e774f3f1bc448/Untitled%201.png)

undefined는 가비지 컬렉터가 제거하기 전까지는 메모리 어딘가에 계속해서 존재하게 된다.

**불변성을 갖는 원시값을 할당한 변수는 재할당 이외에 변수값을 변경할 수 있는 방법이 없다.**

### 문자열과 불변성

문자열 타입은 1글자당 2바이트의 메모리 공간이 필요하다. 숫자는 8바이트로 고정이다.

따라서 10000은 8바이트이지만, ‘10000’은 10바이트가 필요하다.

문자열의 내용이 바뀌는 경우에도 불변성이 적용된다.

```jsx
var str='Hello';
str='World';
```

str이라는 변수가 Hello의 주소를 가리키다가 World의 주소를 가리키도록 변한 것이다.

문자열은 유사배열객체이면서 이터러블 하면서 이렇게 접근할 수 있다.

하지만, 한문자만 변경시킬 수 없다.

```jsx
var str='string';
str[0]='T'
console.log(str) //string
```

⇒ 이 때문에 원시값은 예기치 못한 변경으로부터 자유롭다.

### 메모리주소 전달(값에 의한 전달)

```jsx
var score = 80;
var copy = score;
 
console.log(score, copy); //80 80
score = 100;
console.log(score, copy); // 100 80
```

해당 과정은 두가지로 구현이 가능하며, 구현방법은 엔진 제조사에 따라 미묘하게 차이날 수 있음

1. 80이 두가지 생긴다.

![Untitled](11%20%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%89%E1%85%B5%20%E1%84%80%E1%85%A1%E1%86%B9%E1%84%80%E1%85%AA%20%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%E1%84%8B%E1%85%B4%20%E1%84%87%E1%85%B5%E1%84%80%E1%85%AD%206ecfc068280d4667846e774f3f1bc448/Untitled%202.png)

![Untitled](11%20%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%89%E1%85%B5%20%E1%84%80%E1%85%A1%E1%86%B9%E1%84%80%E1%85%AA%20%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%E1%84%8B%E1%85%B4%20%E1%84%87%E1%85%B5%E1%84%80%E1%85%AD%206ecfc068280d4667846e774f3f1bc448/Untitled%203.png)

1. 80의 주소값을 공유한다.
    
    
    ![Untitled](11%20%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%89%E1%85%B5%20%E1%84%80%E1%85%A1%E1%86%B9%E1%84%80%E1%85%AA%20%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%E1%84%8B%E1%85%B4%20%E1%84%87%E1%85%B5%E1%84%80%E1%85%AD%206ecfc068280d4667846e774f3f1bc448/Untitled%204.png)
    
    ![Untitled](11%20%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%89%E1%85%B5%20%E1%84%80%E1%85%A1%E1%86%B9%E1%84%80%E1%85%AA%20%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%E1%84%8B%E1%85%B4%20%E1%84%87%E1%85%B5%E1%84%80%E1%85%AD%206ecfc068280d4667846e774f3f1bc448/Untitled%205.png)
    

어떻게 해석하든 중요한 것은 두 변수의 원시 값은 서로 다른 메모리 공간에 지정된 별개의 값이 되어 어느 한쪽에서 재할당을 통해 값을 변경해도 서로 간섭할 수 없다는 것이다.

# 객체

객체는 프로퍼티 개수가 정해져 있지 않으며, 동적으로 추가하고 삭제할 수 있다.

또한 프로퍼티의 값에도 제약이 없다.

따라서 원시값과 다르게 작동한다.

<aside>
💡 프로퍼티 키를 인덱스로 사용하는 해시테이블이 아니라 **히든클래스**라는 방식을 사용함(V8엔진기준)

</aside>

[V8의 히든 클래스 이야기](https://engineering.linecorp.com/ko/blog/v8-hidden-class/)

### 변경가능한 값

객체가 할당된 변수를 통해 객체의 주소값, 즉 참조값에 접근할 수 있다.

![Untitled](11%20%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%89%E1%85%B5%20%E1%84%80%E1%85%A1%E1%86%B9%E1%84%80%E1%85%AA%20%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%E1%84%8B%E1%85%B4%20%E1%84%87%E1%85%B5%E1%84%80%E1%85%AD%206ecfc068280d4667846e774f3f1bc448/Untitled%206.png)

```jsx
const obj={
	name:"Kim",
	age:11,
};
```

이렇게 되면 객체의 실제값은 변경가능한 값이 된다.

따라서 수정하면 이런식으로 바뀐다.

```jsx
obj.age=12;
obj.grade=4.5;
```

![Untitled](11%20%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%89%E1%85%B5%20%E1%84%80%E1%85%A1%E1%86%B9%E1%84%80%E1%85%AA%20%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%E1%84%8B%E1%85%B4%20%E1%84%87%E1%85%B5%E1%84%80%E1%85%AD%206ecfc068280d4667846e774f3f1bc448/Untitled%207.png)

새로 할당하지 않으며, 따라서 obj의 주소값 역시 변하지 않는다.

이는 객체의 크기가 매우 클 수 도 있고, 프로퍼티 값이 객체일 수도 있기때문이다.

하지만 이때문에, 복사를 하게되면 참조 주소를 공유하게 되어 하나의 객체를 공유하게 된다.

### 참조에 의한 전달

```jsx
var person={
	name:"Kim",
	age:12,
	grade:4.5,
}
var copy=person;
```

이렇게 하게되면 person과 copy는 같은 주소값을 가리키게 되어, 같은 객체를 공유(참조)한다.

![Untitled](11%20%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%89%E1%85%B5%20%E1%84%80%E1%85%A1%E1%86%B9%E1%84%80%E1%85%AA%20%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%E1%84%8B%E1%85%B4%20%E1%84%87%E1%85%B5%E1%84%80%E1%85%AD%206ecfc068280d4667846e774f3f1bc448/Untitled%208.png)

이렇게 되면 둘 중 하나에 접근해서 값을 바꾸게 될 경우, 다른쪽에서도 값이 바뀌었음을 확인할 수있다.

```jsx
person.age=13;
copy.name="응애";
console.log(copy) //{name:"응애", age:13, grade:4.5}
```

### 비교해보기

```jsx
obj1={};
obj2=obj1;
console.log(obj2===obj1); //true
obj3={};
console.log(obj1===obj2) //false
```

obj1과 obj3는 다른 참조값을 가지기에 false라고 나온다.

```jsx
obj1={
	props:'',
}
obj2={
	props:'',
}
console.log(obj1.props===obj2.props2); //true
```

각 props는 ‘’이라는 문자열 원시값으로 평가되기 때문에 true가 나오게 된다.