# 12 함수

# 함수란?

일련의 과정을 문으로 구현하고 코드 블록으로 감싸서 하나의 실행단위로 정의한 것

함수는 JS에서 호출할 수 있는 객체이다.

### 함수의 구성요소

매개변수, 인수, 반환값

```jsx
function add(x,y){
	return x+y;
}
add(1,5);
```

add가 함수이름, (x,y)가 매개변수 x+y가 반환값 {…}이 몸체이다.

add(1,5)를 통해 호출했고 1,5가 인수이다.

### 함수를 사용하는 이유

1. 편의성
    
    코드의 중복을 낮추고 재사용성을 높힘
    
2. 신뢰성
    
    코드 실수가 줄어듦
    
3. 가독성
    
    적절한 함수이름을 통해 내부 코드 이해 없이도 함수의 역할 파악이 가능해짐
    

## 함수리터럴

JS함수는 객체 타입의 값이므로, 리터럴으로 생성할 수 있다.

```jsx
var f=function(x,y){
	return x+y;
};
```

### 함수 리터럴의 구성 요소

1. 함수이름
    
    함수 이름은 식별자이므로 식별자 네이밍 규칙을 준수한다
    
    함수 이름은 함수 몸체 내에서만 참조할 수 있는 식별자이다.
    
    함수 이름을 생략할 수 있다. 이름이 있는 함수를 **기명함수**, 없는 함수를 **익명함수**라 한다.
    
2. 매개변수 목록
    
    0개 이상의 매개변수를 소괄호로 감싸고 쉼표로 구분한다.
    
    각 매개 변수에는 함수를 호출할 때 지정한 인수가 순서대로 할당된다.
    
    매개변수는 함수 몸체 내에서 변수와 동일하게 취급된다. → 네이밍 규칙을 준수한다.
    
3. 함수몸체
    
    호출되었을때 일괄적으로 실행될 문들의 실행단위로 정의한 코드블록이다.
    
    함수 호출에 의해 실행된다.
    

## 함수 정의

함수의 호출전에 인수를 받을 매개변수와 실행할 문들, 반환할 값을 지정하는 것을 말한다.

방법에는 4가지가 있다.

### 함수 선언문

```jsx
function add(x,y){
	return x+y;
}
```

함수선언문은 함수 이름을 생략할 수 없다.

함수선언문은 표현식이 아닌 문이다. → 값으로 평가되지 않는다.

다만, 변수에 할당될 수 있다. 이는 기명함수 리터럴은 함수 선언문 또는 함수 리터럴 표현식으로 해석될 수 있기 때문이다. 변수에 할당되는 경우 함수 리터럴 표현식으로 해석하기때문에 가능하다.

**함수 선언문은 암묵적으로 함수이름에 해당하는 식별자를 만든다.** 

해당 식별자에 함수 객체를 할당하여 함수 몸통 외부에서도 호출할 수 있게 한다.

즉, JS의 함수는 함수 이름으로 호출하는 게 아니라 함수 객체를 가리키는 식별자로 호출한다.

```jsx
var add = function foo(x,y){
	return x+y;
}
console.log(add(2,5)); //7
console.log(foo(x,5)); //ReferenceError: foo is not defined
```

### 함수 표현식

```jsx
var add = function(x,y){
	return x+y;
};
```

함수는 일급객체이다. 즉, 값의 성질을 갖는다.

1. 값처럼 변수에 할당딘다.
2. 프로퍼티 값이 될 수 있다.
3. 배열의 요소가 될 수 있다.

함수 표현식으로 정의된 함수는 표현식이 나오기 전까지 사용할 수 없다.

```jsx
console.log(add); //[Function]
console.log(foo); //undefined
function add(x, y) {
  return x + y;
} //함수 호이스팅
var foo = function () {
  console.log('foo');
}; //변수 호이스팅
```

### Function 생성자

```jsx
var add = new Function('x','y','return x+y');
```

일반적이지도 않고 바람직하지도 않다.

이렇게 생성한 함수는 클로저를 생성하지 않는다.

### 화살표 함수(ES6)

```jsx
var add = (x,y) => x+y;
```

화살표를 사용해 간력하게 함수를 선언함

화살표 함수는 항상 익명함수이다.

표현방식 뿐 아니라 동작도 간략화되어있다.

1. this 바인딩 방식이 다름
2. prototype프로퍼티가 없음
3. arguments객체를 생성하지 않음

## 함수 호출

함수식별자와 함수호출연산자()로 호출된다.

호출시 실행흐름을 중단하고 해당 함수로 실행흐름을 옮긴다. 이때 매개변수에 인수가 할당되고 몸체의 문들이 실행된다.

1. 함수가 호출될 때 몸체 내에서 암묵적으로 매개변수가 생성되고, undefined로 초기화 된 이후 인수가 할당된다.
2. 매개변수는 함수 내부에서만 유효하다.
3. **함수는 매개변수의 개수와 인수의 개수가 일치하는지 체크하지 않는다.** 
    
    인수가 할당되지 않는경우, 값은 당연하게도 undefined이다.
    
    ```jsx
    function add(x,y){
    	return x+y;
    }
    add(7) //NaN(7+undefined)
    ```
    
    인수가 더 많은 경우, 초과된 인수는 결과에 무시되며, 암묵적으로 arguments 객체의 프로퍼티로 보관된다.
    
    ```jsx
    function add(x,y){
    	console.log(arguments); //[Arguments] { '0': 2, '1': 5, '2': 7 }
    	return x+y;
    
    }
    add(2,5,7) //7
    ```
    

## 인수

매개변수의 최대개수는 3개 이상을 넘지 않도록 한다.

함수는 한가지 일만 해야하며, 가급적 작게 만든다.

객체를 인수로 받는경우, 부수효과에 주의한다.

## 반환문

return 키워드와 **표현식**으로 이뤄진 반환문을 통해 실행 결과를 함수 외부로 반환한다.

반환문의 역할

1. 함수의 실행을 중단하고, 함수 몸체를 빠져나간다. → 이후의 코드는 실행되지 않는다.
2. 반환문은 return 키워드 뒤에 오는 표현식을 평가해서 반환한다. 이후 값이 명확하지 않으면 undefined를 반환한다.
3. 반환문은 생략할 수 있다. 암묵적으로 return;을 실행한다.
4. 반환문은 함수 몸체내부에서만 사용한다.

# 참조에 의한 전달과 부수효과

```jsx
function changer(primitive, obj) {
  primitive += 100;
  obj.name = 'Kim';
}
var num = 100;
var person = {
  name: 'Lee',
};
console.log(num, person);
changer(num, person); //객체 훼손됨
console.log(num, person);
```

원시값은 복사되어 전달되므로 원래 값이 훼손되지 않는다.

객체는 참조값이 복사되어 전달되므로, 원래 값이 훼손되게 된다.

⇒ 코드의 복잡성을 증가 시키고 가독성을 해치며, 결국은 유지보수가 힘든 코드가 된다.

## 다양한 함수 형태

### 즉시 실행함수

(function(){})();의 형태로 한번 호출할 수 있으며, 다시 호출할 수 없다.

반드시 그룹연산자(())로 감싸야 한다. 그렇지 않으면 함수 선언문으로 해석하여 에러가 발생한다.

값으로 바로 평가하여 함수 객체를 만들 수 있는 것이면 그룹연산자가 아니어도 된다. +,! 등을 사용할 수 있다.

### 재귀함수

자기 자신을 호출하는 함수

반드시 탈출조건을 만들어야 함

### 중첩함수

함수 내부에 정의된 함수

외부함수의 내부에서만 사용가능함

내부 함수가 헬퍼함수 역할을 함

### 콜백함수

중첩함수의 내부함수를 함수의 인자로 전달하여 함수를 유연하게 만드는 것

받는 함수를 고차함수라 함

### 순수함수

외부 상태를 변경하지 않고, 외부 상태(전역변수, 서버데이터, 파일, Console, DOM)에 의존하지도 않는, 부수효과가 없는 함수

외부 상태에 의존하지 않아도 내부 상태가 계속해서 변화하면(현재시각) 순수함수가 아님

반대를 비순수함수라고 함

순수함수는 일반적으로 최소 하나 이상의 인수를 전달받음.

순수함수와 보조 함수의 조합을 통해 외부 상태를 변경하는 부수효과를 최소화 하여 불변성을 지향하는 프로그래밍 패러다임을 **함수형 프로그래밍**이라고 함